from scapy.layers.inet import  IP, TCP, sr1
import socket
from datetime import datetime
from netaddr import IPRange
import sys
import time
import argparse
from concurrent.futures import ThreadPoolExecutor, as_completed, wait
 

class scannerScapy:
    def __init__(self, ip_list, port_list = None, typesc = "fsyn", tm = 5, w = 0):
        self.ip_list = ip_list
        self.port_list = port_list
        self.typesc = typesc
        self.tm = tm
        self.w = w
        
    def do_get(self, ip, port):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(self.tm)
        val = None
        try:
            s.connect((ip, port))
            msg = "GET / HTTP/1.0\r\n\r\n"
            s.sendall(msg.encode('utf-8'))
        except socket.error: 
            #print ("Error sending data: %s" % e) 
            return None  
        
        try:
            val = s.recv(1024)
            #print(ip, port, val)
            s.close()
        except socket.error:
            return None
            #print ("Error recv data: %s" % e) 
        return val

    def connect_scan_port(self, ip, port):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(self.tm)
        try:
            s.connect((ip, port))
            msg = "GET / HTTP/1.0\r\n\r\n"
            s.sendall(msg.encode('utf-8'))
        except socket.error as e: 
            print ("Error sending data: %s" % e) 
            return None  
        
        try:
            val = s.recv(1024)
            print(ip, port, val)
            s.close()
        except socket.error as e: 
            print ("Error recv data: %s" % e) 
        return ip, port


    def syn_scan_port(self, ip, port):
        syn_packet = IP(dst=ip) / TCP(dport=port, flags="S")
        if(self.w > 0):
            time.sleep(self.w)
        resp_packet = sr1(syn_packet, timeout=self.tm, verbose=False)
        if resp_packet is not None:
            #SYN_ACK 0x12
            if resp_packet.getlayer('TCP'):
                if (resp_packet.sprintf('%TCP.flags%') == "SA"):
                    print(f"{ip}:{port} is open/{resp_packet.sprintf('%TCP.sport%')}")
                    return ip, port
        return None
    
    def fin_scan_port(self, ip, port):
        fin_packet = IP(dst=ip) / TCP(dport=port, flags="F")
        if(self.w > 0):
            time.sleep(self.w)
        resp_packet = sr1(fin_packet, timeout=10, verbose=False)
        if resp_packet is not None:
            if resp_packet.getlayer('ICMP'):
                print(f"{ip}:{port} is filtered/{resp_packet.sprintf('%TCP.sport%')}")
        else:
            print(f"{ip}:{port} is open/{fin_packet.sprintf('%TCP.dport%')}")
            return ip, port
        return None
    
        
    def _scan(self, mode, method):
        result = {}
        with ThreadPoolExecutor(max_workers=mode) as executor:
             futures = [executor.submit(method, str(ip), port) for ip in self.ip_list for port in self.port_list]
        
        for future in as_completed(futures):
            res = future.result()
            if res is not None:
                (ip, port) = res
                if ip not in result:
                    result[ip] = list()
                result[ip].append(port)
        wait(futures)
        return result

        
    def scan(self):
        print("scan ...")
        if self.typesc == "syn":
            if self.port_list:
                return self._scan(1, self.syn_scan_port)
        if self.typesc == "fin":
            if self.port_list:
                return self._scan(1, self.fin_scan_port)
        if self.typesc == "fsyn":
            if self.port_list:
                return self._scan(None, self.syn_scan_port)
        if self.typesc == "ffin":
            if self.port_list:
                return self._scan(None, self.fin_scan_port)
        if self.typesc == "cnt":
            if self.port_list:
                return self._scan(1, self.connect_scan_port)
        if self.typesc == "fcnt":
            if self.port_list:
                return self._scan(None, self.connect_scan_port)
        
def get_port_range_list(a, z):
    ports = [c for c in range(a, z+1)]
    return ports
    
    #ip_range = IPRange('192.168.1.0', '192.168.1.20')
def get_ip_range(a, z):
    ip_range = IPRange(a, z)
    return ip_range

def createParser ():
    parser = argparse.ArgumentParser()
    groupIP = parser.add_mutually_exclusive_group(required=True)
    groupIP.add_argument('-i','--ip', nargs=1)
    groupIP.add_argument('-n', '--net', nargs=2)
    
    groupPORT = parser.add_mutually_exclusive_group()
    groupPORT.add_argument('-p', '--port', nargs='+', type=int)
    groupPORT.add_argument('-pr', '--port_range', nargs=2, type=int)
    
    parser.add_argument('-s', '--scanner', choices=['syn', 'fin', 'fsyn', 'ffin', 'cnt', 'fcnt'], default='fsyn')
    parser.add_argument('-w', '--wait', nargs='?', type=int, default=0)
    parser.add_argument('-t', '--timeout', nargs='?', type=int, default=2)
    return parser
    
if __name__ == '__main__':
    start = datetime.now()
    print(start)
    parser = createParser()
    args = parser.parse_args (sys.argv[1:])
    ip_range = None;
    port_list = [];
    if args.ip:
        ip_range = get_ip_range(args.ip[0], args.ip[0])
    if args.net:
        ip_range = get_ip_range(args.net[0], args.net[1])
    if args.port:
        port_list = args.port;
    if args.port_range:
        port_list = get_port_range_list(args.port_range[0], args.port_range[1])
    
    scan = scannerScapy(ip_range, 
    port_list = port_list, 
    typesc = args.scanner,
    tm = args.timeout, 
    w = args.wait)
    print(scan.scan())
    ends = datetime.now()
    print(ends)
 #soc server tor
